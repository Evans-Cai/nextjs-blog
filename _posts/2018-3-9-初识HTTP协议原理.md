---
layout:     post
title:      http协议原理
subtitle:   http协议原理学习记录心得总结
date:       2018-3-9 17:33:02
author:     gankai
header-img: img/vue.jpg
catalog: true
tags:
    - http
    - tcp
    - udp
---

# http协议原理

## 2018年3月9日00:24:49  001

<h1>http的三次握手是什么意思,为什么要有三次握手?</h1>
**答:**

  `为了防止服务端开启一些无用的链接,因为网络传送是有延时的,服务器开销的问题.中间可能隔了很长的距离(比如光纤,或者说各种代理服务器),在传送过程中,第一次握手,客户端发送一次创建链接的请求数据比如:`SYN = 1, Seq = X`,服务端接收到请求,创建链接,将数据(SYN = 1,ACK = X+1, Seq = Y)返回给客户端,但是,在这个传送过程中,数据可能会丢失,服务端不知道客户端是否接收到了数据,然后服务端就会将端口一直开着等待客户端的第三次握手,也就是说服务端会等待一段时间,如果一段时间之后,没有进行第三次握手,服务端就会将端口关掉,如果客户端没有接到服务端的第二次握手,就不会再次请求;`

  `weshak抓包工具`

  URL: 统一资源定位器;

  URI: 统一资源定位符;

  URN: 永久资源定位符(在资源移动之后, 还能被找到,目前还没有非常成熟的使用方案);

<h4>curl的使用</h4>

  在git bash 中 `crul baidu.com`查看,或者,crul -v www.baidu.com 看请求的所有报文的详细信息:
请求的:
      Trying 180.97.33.108...
    * TCP_NODELAY set
    * Connected to www.baidu.com (180.97.33.108) port 80 (#0)
    > GET / HTTP/1.1
    > Host: www.baidu.com
    > User-Agent: curl/7.63.0
    > Accept: */*
    >
返回的:

    < HTTP/1.1 200 OK
    < Accept-Ranges: bytes
    < Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
    < Connection: Keep-Alive
    < Content-Length: 2381
    < Content-Type: text/html
    < Date: Sat, 09 Mar 2019 11:17:45 GMT
    < Etag: "588604f8-94d"
    < Last-Modified: Mon, 23 Jan 2017 13:28:24 GMT
    < Pragma: no-cache
    < Server: bfe/1.0.8.18
    < Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
    <


<h3>浏览器缓存相关 Cache-Control  客户端缓存的可缓存性</h3>

`public` 任何地方都能缓存,

`private`指定地方能缓存

`no-cache`没有缓存(你可以在本地进行缓存,不过需要经过服务器的验证同意)

`no-store` 永远都不用缓存,只能每次都去服务器上获取新的数据,只要使用了这个任何有关缓存的都会失效,权重很高;

`no-transform`告诉代理服务器不能随便进行压缩转换,改变内容;

`max-age=<seconds>` 缓存到期时间(秒为单位)

`s-maxage=<seconds>`只有设置带来的时候,才会走这个,缓存到期时间,这是专门为代理服务器设置的

`must-revalidate` 重新验证 `proxy-revalidate`缓存服务器中

以上头消息,非约束性的,可以按照这个规范去做,

    response.writeHead(200, {
         'Content-Type': 'text/javascript',
         'Cache-Control':'max-age=20,public'  // 开启缓存
     })
     response.end("console.log('script.js')")

***这也就是为什么前端请求数据的时候,url上会加上一串哈希码,为的是清空浏览器的缓存.***

<h3> `Last-Modified` 上次修改时间</h3>

    配合If-Modified-Since或者If-Unmodified-Since使用 对比上次修改时间以验证资源是否更新

    代码:response.writeHead(200, {
            'Content-Type': 'text/javascript',
            'Cache-Control':'max-age=200000000,no-cache',  //是否开启缓存
            'Last-Modified':'123',
            'Etag':'777'
        })
    Response Header:
        Cache-Control: max-age=200000000,no-cache  //哪怕设置了no-chche也会访问后台数据
        Connection: keep-alive
        Content-Type: text/javascript
        Date: Sun, 10 Mar 2019 12:33:54 GMT
        Etag: 777                                    // 第一次发送请求
        Last-Modified: 123                           // 第一次发送请求
        Transfer-Encoding: chunked

    Request Headers:
        GET /script.js HTTP/1.1
        Host: localhost:8888
        Connection: keep-alive
        If-None-Match: 777              // 配合 Etag 第一次发送请求带上的
        If-Modified-Since: 123          // 配合 Last-Modified
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36
        Accept: */*
        Referer: http://localhost:8888/
        Accept-Encoding: gzip, deflate, br
        Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
        Cookie: _ga=GA1.1.1520046618.1549612093; Hm_lvt_b50bf2b12b5338a1845e33832976fd68=1549789561


`Etag` 数据签名  

    配合  If-Match 或者 If-Non-Match 使用,对比资源的签名判断是否使用缓存

    const Etag = request.headers['if-none-match']
           if (Etag === '777') {
               response.writeHead(304, {
                   'Content-Type': 'text/javascript',
                   'Cache-Control': 'max-age=200000000,no-cache', //是否开启缓存
                   'Last-Modified': '123',
                   'Etag': '777'
               })
               response.end("")
    // 这个时候,服务器返回的是空,但是显示的却是上次缓存的数据 `console.log('script.js')`
    修改返回的数据为 response.end("11111"),但是网页返回的还是`console.log('script.js')`
`type:为Not Modified 意思是未从后台获取数据,直接从浏览器获取数据;
304code的作用是告诉浏览器资源没有被修改,在请求数据的时候,可以直接从缓存body中读取,无需从后台获取.`
<h3>Cookie</h3>

通过设置`Set-CooKie`设置,下次请求会自动带上,键值对的形式可以设置多个.

***属性***

通过设置`max-age`和`expires`设置过期时间,`Secure`只在https的时候发送,如果设置了`HttpOnly`就无法通过document.cooKie访问,这样就可以防止`csrf`攻击,原理就是在用户的浏览器js脚本中放置一种链接.引导用户将自己的cookie发送的攻击者指定的网站,从而攻击者就可以获取用户所有的数据资料,冒充用户进行违法操作;


    response.writeHead(200, {
         'Content-Type': 'text/html',
         'Set-Cookie': ['id=123;max-age=3', 'abc=456;HttpOnly']
         // 设置第一个cookie的超时为2s,第二个cookie的属性为HttpOnly,不允许js访问这个cookie;
       })
