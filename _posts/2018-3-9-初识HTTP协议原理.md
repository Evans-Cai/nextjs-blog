---
layout:     post
title:      http协议原理
subtitle:   http协议原理学习记录心得总结
date:       2018-3-9 17:33:02
author:     gankai
header-img: img/vue.jpg
catalog: true
tags:
    - http
    - tcp
    - udp
---

# http协议原理

## 2018年3月9日00:24:49  001

<h1>http的三次握手是什么意思,为什么要有三次握手?</h1>
**答:**

  `为了防止服务端开启一些无用的链接,因为网络传送是有延时的,服务器开销的问题.中间可能隔了很长的距离(比如光纤,或者说各种代理服务器),在传送过程中,第一次握手,客户端发送一次创建链接的请求数据比如:`SYN = 1, Seq = X`,服务端接收到请求,创建链接,将数据(SYN = 1,ACK = X+1, Seq = Y)返回给客户端,但是,在这个传送过程中,数据可能会丢失,服务端不知道客户端是否接收到了数据,然后服务端就会将端口一直开着等待客户端的第三次握手,也就是说服务端会等待一段时间,如果一段时间之后,没有进行第三次握手,服务端就会将端口关掉,如果客户端没有接到服务端的第二次握手,就不会再次请求;`

  `weshak抓包工具`

  URL: 统一资源定位器;

  URI: 统一资源定位符;

  URN: 永久资源定位符(在资源移动之后, 还能被找到,目前还没有非常成熟的使用方案);

<h4>curl的使用</h4>

  在git bash 中 `crul baidu.com`查看,或者,crul -v www.baidu.com 看请求的所有报文的详细信息:
请求的:
      Trying 180.97.33.108...
    * TCP_NODELAY set
    * Connected to www.baidu.com (180.97.33.108) port 80 (#0)
    > GET / HTTP/1.1
    > Host: www.baidu.com
    > User-Agent: curl/7.63.0
    > Accept: */*
    >
返回的:

    < HTTP/1.1 200 OK
    < Accept-Ranges: bytes
    < Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
    < Connection: Keep-Alive
    < Content-Length: 2381
    < Content-Type: text/html
    < Date: Sat, 09 Mar 2019 11:17:45 GMT
    < Etag: "588604f8-94d"
    < Last-Modified: Mon, 23 Jan 2017 13:28:24 GMT
    < Pragma: no-cache
    < Server: bfe/1.0.8.18
    < Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
    <


<h3>浏览器缓存相关 Cache-Control  客户端缓存的可缓存性</h3>

`public` 任何地方都能缓存,

`private`指定地方能缓存

`no-cache`没有缓存(你可以在本地进行缓存,不过需要经过服务器的验证同意)

`no-store` 永远都不用缓存,只能每次都去服务器上获取新的数据,只要使用了这个任何有关缓存的都会失效,权重很高;

`no-transform`告诉代理服务器不能随便进行压缩转换,改变内容;

`max-age=<seconds>` 缓存到期时间(秒为单位)

`s-maxage=<seconds>`只有设置带来的时候,才会走这个,缓存到期时间,这是专门为代理服务器设置的

`must-revalidate` 重新验证 `proxy-revalidate`缓存服务器中

以上头消息,非约束性的,可以按照这个规范去做,

    response.writeHead(200, {
         'Content-Type': 'text/javascript',
         'Cache-Control':'max-age=20,public'  // 开启缓存
     })
     response.end("console.log('script.js')")

***这也就是为什么前端请求数据的时候,url上会加上一串哈希码,为的是清空浏览器的缓存.***

<h3> `Last-Modified` 上次修改时间</h3>

    配合If-Modified-Since或者If-Unmodified-Since使用 对比上次修改时间以验证资源是否更新

    代码:response.writeHead(200, {
            'Content-Type': 'text/javascript',
            'Cache-Control':'max-age=200000000,no-cache',  //是否开启缓存
            'Last-Modified':'123',
            'Etag':'777'
        })
    Response Header:
        Cache-Control: max-age=200000000,no-cache  //哪怕设置了no-chche也会访问后台数据
        Connection: keep-alive
        Content-Type: text/javascript
        Date: Sun, 10 Mar 2019 12:33:54 GMT
        Etag: 777                                    // 第一次发送请求
        Last-Modified: 123                           // 第一次发送请求
        Transfer-Encoding: chunked

    Request Headers:
        GET /script.js HTTP/1.1
        Host: localhost:8888
        Connection: keep-alive
        If-None-Match: 777              // 配合 Etag 第一次发送请求带上的
        If-Modified-Since: 123          // 配合 Last-Modified
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36
        Accept: */*
        Referer: http://localhost:8888/
        Accept-Encoding: gzip, deflate, br
        Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
        Cookie: _ga=GA1.1.1520046618.1549612093; Hm_lvt_b50bf2b12b5338a1845e33832976fd68=1549789561


`Etag` 数据签名  

    配合  If-Match 或者 If-Non-Match 使用,对比资源的签名判断是否使用缓存

    const Etag = request.headers['if-none-match']
           if (Etag === '777') {
               response.writeHead(304, {
                   'Content-Type': 'text/javascript',
                   'Cache-Control': 'max-age=200000000,no-cache', //是否开启缓存
                   'Last-Modified': '123',
                   'Etag': '777'
               })
               response.end("")
    // 这个时候,服务器返回的是空,但是显示的却是上次缓存的数据 `console.log('script.js')`
    修改返回的数据为 response.end("11111"),但是网页返回的还是`console.log('script.js')`
`type:为Not Modified 意思是未从后台获取数据,直接从浏览器获取数据;
304code的作用是告诉浏览器资源没有被修改,在请求数据的时候,可以直接从缓存body中读取,无需从后台获取.`
<h3>Cookie</h3>

通过设置`Set-CooKie`设置,下次请求会自动带上,键值对的形式可以设置多个.

***属性***

通过设置`max-age`和`expires`设置过期时间,`Secure`只在https的时候发送,如果设置了`HttpOnly`就无法通过document.cooKie访问,这样就可以防止`csrf`攻击,原理就是在用户的浏览器js脚本中放置一种链接.引导用户将自己的cookie发送的攻击者指定的网站,从而攻击者就可以获取用户所有的数据资料,冒充用户进行违法操作;


    response.writeHead(200, {
         'Content-Type': 'text/html',
         'Set-Cookie': ['id=123;max-age=3', 'abc=456;HttpOnly']
         // 设置第一个cookie的超时为2s,第二个cookie的属性为HttpOnly,不允许js访问这个cookie;
       })

------------------

#### 不过，说 HTTP/1.1 是“小幅度修正”也不太确切，它还是有很多实质性进步的。毕竟经过了多年的实战检验，比起 0.9/1.0 少了“学术气”，更加“接地气”，同时表述也更加严谨。HTTP/1.1 主要的变更点有：

<ol>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ol>

#### HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：

<ol>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。</li>
</ol>

*问*

<ul>
<li>你是怎么理解 HTTP 字面上的“超文本”和“传输协议”的？</li>
<li>能否谈一下你对 HTTP 的认识？越多越好。</li>
<li>HTTP 有什么特点？有什么优点和缺点？</li>
<li>HTTP 下层都有哪些协议？是如何工作的？</li>
<li>……</li>
</ul>

<span class="orange">HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</span>

<p><strong>HTTP 不是一个孤立的协议</strong>。</p>

<p>在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p>

<img src="https://static001.geekbang.org/resource/image/27/cc/2781919e73f5d258ff1dc371af632acc.png" alt="">

<b>指出一点误解：两个浏览器不能通信。服务器可以当客户端，但浏览器只是客户端。</b>

<p>上网就要用到浏览器，常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，还有小众的 Opera 以及国内的各种“换壳”的“极速”“安全”浏览器。</p>

<p><img src="https://static001.geekbang.org/resource/image/61/8b/613fffb6defee1735431dc5f89085d8b.png" alt="unpreview"></p>

<p><strong>CDN</strong>，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</p>
<p>CDN 有什么好处呢？</p>
<p>简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</p>

<p>CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分，我也会在后面用一讲的篇幅来专门讲解 CDN。</p>

<p><strong>TCP 协议</strong>是“<strong><span class="orange">T</span></strong>ransmission <strong><span class="orange">C</span></strong>ontrol <strong><span class="orange">P</span></strong>rotocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供<span class="orange">可靠的、字节流</span>形式的通信，是 HTTP 协议得以实现的基础。</p>

<p>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</p>