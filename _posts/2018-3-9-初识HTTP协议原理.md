---
layout:     post
title:      http协议原理
subtitle:   http协议原理学习记录心得总结
date:       2018-3-9 17:33:02
author:     gankai
header-img: img/vue.jpg
catalog: true
tags:
    - http
    - tcp
    - udp
---

# http协议原理

## 2018年3月9日00:24:49  001

<h1>http的三次握手是什么意思,为什么要有三次握手?</h1>
**答:**

  `为了防止服务端开启一些无用的链接,因为网络传送是有延时的,服务器开销的问题.中间可能隔了很长的距离(比如光纤,或者说各种代理服务器),在传送过程中,第一次握手,客户端发送一次创建链接的请求数据比如:`SYN = 1, Seq = X`,服务端接收到请求,创建链接,将数据(SYN = 1,ACK = X+1, Seq = Y)返回给客户端,但是,在这个传送过程中,数据可能会丢失,服务端不知道客户端是否接收到了数据,然后服务端就会将端口一直开着等待客户端的第三次握手,也就是说服务端会等待一段时间,如果一段时间之后,没有进行第三次握手,服务端就会将端口关掉,如果客户端没有接到服务端的第二次握手,就不会再次请求;`

  `weshak抓包工具`

  URL: 统一资源定位器;

  URI: 统一资源定位符;

  URN: 永久资源定位符(在资源移动之后, 还能被找到,目前还没有非常成熟的使用方案);

<h4>curl的使用</h4>

  在git bash 中 `crul baidu.com`查看,或者,crul -v www.baidu.com 看请求的所有报文的详细信息:
请求的:
      Trying 180.97.33.108...
    * TCP_NODELAY set
    * Connected to www.baidu.com (180.97.33.108) port 80 (#0)
    > GET / HTTP/1.1
    > Host: www.baidu.com
    > User-Agent: curl/7.63.0
    > Accept: */*
    >
返回的:

    < HTTP/1.1 200 OK
    < Accept-Ranges: bytes
    < Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
    < Connection: Keep-Alive
    < Content-Length: 2381
    < Content-Type: text/html
    < Date: Sat, 09 Mar 2019 11:17:45 GMT
    < Etag: "588604f8-94d"
    < Last-Modified: Mon, 23 Jan 2017 13:28:24 GMT
    < Pragma: no-cache
    < Server: bfe/1.0.8.18
    < Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
    <


<h3>浏览器缓存相关 Cache-Control  客户端缓存的可缓存性</h3>

`public` 任何地方都能缓存,

`private`指定地方能缓存

`no-cache`没有缓存(你可以在本地进行缓存,不过需要经过服务器的验证同意)

`no-store` 永远都不用缓存,只能每次都去服务器上获取新的数据,只要使用了这个任何有关缓存的都会失效,权重很高;

`no-transform`告诉代理服务器不能随便进行压缩转换,改变内容;

`max-age=<seconds>` 缓存到期时间(秒为单位)

`s-maxage=<seconds>`只有设置带来的时候,才会走这个,缓存到期时间,这是专门为代理服务器设置的

`must-revalidate` 重新验证 `proxy-revalidate`缓存服务器中

以上头消息,非约束性的,可以按照这个规范去做,

    response.writeHead(200, {
         'Content-Type': 'text/javascript',
         'Cache-Control':'max-age=20,public'  // 开启缓存
     })
     response.end("console.log('script.js')")

***这也就是为什么前端请求数据的时候,url上会加上一串哈希码,为的是清空浏览器的缓存.***

<h3> `Last-Modified` 上次修改时间</h3>

    配合If-Modified-Since或者If-Unmodified-Since使用 对比上次修改时间以验证资源是否更新

    代码:response.writeHead(200, {
            'Content-Type': 'text/javascript',
            'Cache-Control':'max-age=200000000,no-cache',  //是否开启缓存
            'Last-Modified':'123',
            'Etag':'777'
        })
    Response Header:
        Cache-Control: max-age=200000000,no-cache  //哪怕设置了no-chche也会访问后台数据
        Connection: keep-alive
        Content-Type: text/javascript
        Date: Sun, 10 Mar 2019 12:33:54 GMT
        Etag: 777                                    // 第一次发送请求
        Last-Modified: 123                           // 第一次发送请求
        Transfer-Encoding: chunked

    Request Headers:
        GET /script.js HTTP/1.1
        Host: localhost:8888
        Connection: keep-alive
        If-None-Match: 777              // 配合 Etag 第一次发送请求带上的
        If-Modified-Since: 123          // 配合 Last-Modified
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36
        Accept: */*
        Referer: http://localhost:8888/
        Accept-Encoding: gzip, deflate, br
        Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
        Cookie: _ga=GA1.1.1520046618.1549612093; Hm_lvt_b50bf2b12b5338a1845e33832976fd68=1549789561


`Etag` 数据签名  

    配合  If-Match 或者 If-Non-Match 使用,对比资源的签名判断是否使用缓存

    const Etag = request.headers['if-none-match']
           if (Etag === '777') {
               response.writeHead(304, {
                   'Content-Type': 'text/javascript',
                   'Cache-Control': 'max-age=200000000,no-cache', //是否开启缓存
                   'Last-Modified': '123',
                   'Etag': '777'
               })
               response.end("")
    // 这个时候,服务器返回的是空,但是显示的却是上次缓存的数据 `console.log('script.js')`
    修改返回的数据为 response.end("11111"),但是网页返回的还是`console.log('script.js')`
`type:为Not Modified 意思是未从后台获取数据,直接从浏览器获取数据;
304code的作用是告诉浏览器资源没有被修改,在请求数据的时候,可以直接从缓存body中读取,无需从后台获取.`
<h3>Cookie</h3>

通过设置`Set-CooKie`设置,下次请求会自动带上,键值对的形式可以设置多个.

***属性***

通过设置`max-age`和`expires`设置过期时间,`Secure`只在https的时候发送,如果设置了`HttpOnly`就无法通过document.cooKie访问,这样就可以防止`csrf`攻击,原理就是在用户的浏览器js脚本中放置一种链接.引导用户将自己的cookie发送的攻击者指定的网站,从而攻击者就可以获取用户所有的数据资料,冒充用户进行违法操作;


    response.writeHead(200, {
         'Content-Type': 'text/html',
         'Set-Cookie': ['id=123;max-age=3', 'abc=456;HttpOnly']
         // 设置第一个cookie的超时为2s,第二个cookie的属性为HttpOnly,不允许js访问这个cookie;
       })

------------------

 不过，说 HTTP/1.1 是“小幅度修正”也不太确切，它还是有很多实质性进步的。毕竟经过了多年的实战检验，比起 0.9/1.0 少了“学术气”，更加“接地气”，同时表述也更加严谨。HTTP/1.1 主要的变更点有：

<ol>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ol>

HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：

<ol>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。</li>
</ol>

*问*

<ul>
<li>你是怎么理解 HTTP 字面上的“超文本”和“传输协议”的？</li>
<li>能否谈一下你对 HTTP 的认识？越多越好。</li>
<li>HTTP 有什么特点？有什么优点和缺点？</li>
<li>HTTP 下层都有哪些协议？是如何工作的？</li>
<li>……</li>
</ul>

<span class="orange">HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</span>

<p><strong>HTTP 不是一个孤立的协议</strong>。</p>

<p>在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p>

<img src="https://static001.geekbang.org/resource/image/27/cc/2781919e73f5d258ff1dc371af632acc.png" alt="">

<b>指出一点误解：两个浏览器不能通信。服务器可以当客户端，但浏览器只是客户端。</b>

<p>上网就要用到浏览器，常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，还有小众的 Opera 以及国内的各种“换壳”的“极速”“安全”浏览器。</p>

<p><img src="https://static001.geekbang.org/resource/image/61/8b/613fffb6defee1735431dc5f89085d8b.png" alt="unpreview"></p>

<p><strong>CDN</strong>，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</p>
<p>CDN 有什么好处呢？</p>
<p>简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</p>

<p>CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分，我也会在后面用一讲的篇幅来专门讲解 CDN。</p>

<p><strong>TCP 协议</strong>是“<strong><span class="orange">T</span></strong>ransmission <strong><span class="orange">C</span></strong>ontrol <strong><span class="orange">P</span></strong>rotocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供<span class="orange">可靠的、字节流</span>形式的通信，是 HTTP 协议得以实现的基础。</p>

<p>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</p>

<p><img src="https://static001.geekbang.org/resource/image/2b/03/2b8fee82b58cc8da88c74a33f2146703.png" alt=""></p>

<p>TCP/IP 协议总共有四层，就像搭积木一样，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。</p>
<p>第一层叫“<strong>链接层</strong>”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</p>
<p>第二层叫“<strong>网际层</strong>”或者“<strong>网络互连层</strong>”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</p>
<p>第三层叫“<strong>传输层</strong>”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</p>
<p>协议栈的第四层叫“<strong>应用层</strong>”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</p>

<p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>

<h2>OSI 网络分层模型</h2>
<p>看完 TCP/IP 协议栈，你可能要问了，“它只有四层，那常说的七层怎么没见到呢？”</p>
<p>别着急，这就是今天要说的第二个网络分层模型：<strong>OSI</strong>，全称是“<strong>开放式系统互联通信参考模型</strong>”（Open System Interconnection Reference Model）。</p>

<p>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</p>

<p><img src="https://static001.geekbang.org/resource/image/3a/dc/3abcf1462621ff86758a8d9571c07cdc.png" alt=""></p>

<ol>
<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>
<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>
<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>
<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>
<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>
<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>
<li>第七层：应用层，面向具体的应用传输数据。</li>
</ol>

<h2>两个分层模型的映射关系</h2>

<p><img src="https://static001.geekbang.org/resource/image/9d/94/9d9b3c9274465c94e223676b6d434194.png" alt=""></p>

<ol>
<li>第一层：物理层，TCP/IP 里无对应；</li>
<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>
<li>第三层：网络层，对应 TCP/IP 的网际层；</li>
<li>第四层：传输层，对应 TCP/IP 的传输层；</li>
<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>
</ol>

<h2>域名的解析</h2>

<p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p>

<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。</li>
</ol>

<p><img src="https://static001.geekbang.org/resource/image/6b/f2/6b020454987543efdd1cf6ddec784bf2.png" alt=""></p>

<p>例如，你要访问“www.apple.com”，就要进行下面的三次查询：</p>

<ol>
<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>
<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>
<li>最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。</li>
</ol>

<p>虽然核心的 DNS 系统遍布全球，服务能力很强也很稳定，但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。</p>

<p>所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“<strong>缓存</strong>”。</p>

<p>首先，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</p>

<p>下面的这张图比较完整地表示了现在的 DNS 架构。</p>

<p><img src="https://static001.geekbang.org/resource/image/e5/ac/e51df3245609880641043af65bba94ac.png" alt=""></p>

<p>在 Nginx 里有这么一条配置指令“resolver”，它就是用来配置 DNS 服务器的，如果没有它，那么 Nginx 就无法查询域名对应的 IP，也就无法反向代理到外部的网站。</p>

<b>对于DNS解析的过程：浏览器DNS缓存->操作系统缓存->Hosts文件->非权威域名服务器->根域名服务器->顶级域名服务器->权威域名服务器</b>

<h2 class="cZCVMzBP_0">08 | 键入网址再按下回车，后面究竟发生了什么？</h2>

<p><img src="https://static001.geekbang.org/resource/image/8a/19/8a5bddd3d8046daf7032c7d60a3d1a19.png" alt=""></p>

<p>再简要叙述一下这次最简单的浏览器 HTTP 请求过程：</p>

<ol>
<li>浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；</li>
<li>浏览器用 TCP 的三次握手与服务器建立连接；</li>
<li>浏览器向服务器发送拼好的报文；</li>
<li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li>
<li>浏览器解析报文，渲染输出页面。</li>
</ol>

<h1 class="cZCVMzBP_0">09 | HTTP报文是什么样子的？</h1>

<h2>报文结构</h2>

<p>你也许对 TCP/UDP 的报文格式有所了解，拿 TCP 报文来举例，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。</p>

<p><img src="https://static001.geekbang.org/resource/image/17/95/174bb72bad50127ac84427a72327f095.png" alt=""></p>

<p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p>

<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
</ol>

<p>这其中前两部分起始行和头部字段经常又合称为“<strong>请求头</strong>”或“<strong>响应头</strong>”，消息正文又称为“<strong>实体</strong>”，但与“<strong>header</strong>”对应，很多时候就直接称为“<strong>body</strong>”。</p>

<p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p>

<p>所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个“空行”。</p>

<p><img src="https://static001.geekbang.org/resource/image/62/3c/62e061618977565c22c2cf09930e1d3c.png" alt=""></p>

<h2>请求行</h2>

<p>了解了 HTTP 报文的基本结构后，我们来看看请求报文里的起始行也就是<strong>请求行</strong>（request line），它简要地描述了<strong>客户端想要如何操作服务器端的资源</strong>。</p>

<p>请求行由三部分构成：</p>

<ol>
<li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本。</li>
</ol>

<p>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p>

<p><img src="https://static001.geekbang.org/resource/image/36/b9/36108959084392065f36dff3e12967b9.png" alt=""></p>

<code class="ps"><table class="hljs-ln"><tbody><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">GET / HTTP/1.1</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line"><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></td></tr></tbody></table><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></code>

<p>在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”</p>

<h2>状态行</h2>

<p>看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“<strong>状态行</strong>”（status line），意思是<strong>服务器响应的状态</strong>。</p>

<p>比起请求行来说，状态行要简单一些，同样也是由三部分构成：</p>

<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>
</ol>

<p><img src="https://static001.geekbang.org/resource/image/a1/00/a1477b903cd4d5a69686683c0dbc3300.png" alt=""></p>

<code class="ps"><table class="hljs-ln"><tbody><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">HTTP/1.1 200 OK</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line"><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></td></tr></tbody></table><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></code>

<p>意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”</p>

<h2>头部字段</h2>

<p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头，我画了两个示意图，你可以看一下。</p>

<p><img src="https://static001.geekbang.org/resource/image/1f/ea/1fe4c1121c50abcf571cebd677a8bdea.png" alt=""></p>

<p><img src="https://static001.geekbang.org/resource/image/cb/75/cb0d1d2c56400fe9c9988ee32842b175.png" alt=""></p>

<p>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</p>

<p>不过使用头字段需要注意下面几点：</p>

<ol>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li>
</ol>

<h2>常用头字段</h2>

<p>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</p>

<ol>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ol>

<p>首先要说的是<strong>Host</strong>字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求<strong>必须出现</strong>的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。</p>

<p>Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。</p>

<p><strong>User-Agent</strong>是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</p>

<p><strong>Date</strong>字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</p>

<p><strong>Server</strong>字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。</p>

<p>Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</p>

<p>实体字段里要说的一个是<strong>Content-Length</strong>，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。</p>

<h1 class="cZCVMzBP_0">10 | 应该如何理解请求方法？</h1>

<p>目前 HTTP/1.1 规定了八种方法，单词<strong>都必须是大写的形式</strong>，我先简单地列把它们列出来，后面再详细讲解。</p>

<ol>
<li>GET：获取资源，可以理解为读取或者下载数据；</li>
<li>HEAD：获取资源的元信息；</li>
<li>POST：向资源提交数据，相当于写入或上传数据；</li>
<li>PUT：类似 POST；</li>
<li>DELETE：删除资源；</li>
<li>CONNECT：建立特殊的连接隧道；</li>
<li>OPTIONS：列出可对资源实行的方法；</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ol>

<p><img src="https://static001.geekbang.org/resource/image/3c/6d/3cdc8ac71b80929f4a94dfeb9ffe4b6d.jpg" alt=""></p>

<p>看看这些方法，是不是有点像对文件或数据库的“增删改查”操作，只不过这些动作操作的目标不是本地资源，而是远程服务器上的资源，所以只能由客户端“请求”或者“指示”服务器来完成。</p>
<p>既然请求方法是一个“指示”，那么客户端自然就没有决定权，服务器掌控着所有资源，也就有绝对的决策权力。它收到 HTTP 请求报文后，看到里面的请求方法，可以执行也可以拒绝，或者改变动作的含义，毕竟 HTTP 是一个“协议”，两边都要“商量着来”。</p>

<p>比如，你发起了一个 GET 请求，想获取“/orders”这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：</p>

<ol>
<li>假装这个文件不存在，直接返回一个 404 Not found 报文；</li>
<li>稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403 Forbidden；</li>
<li>再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用 HEAD 方法获取文件的元信息。</li>
</ol>
<p><strong>GET</strong>方法应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的，自 0.9 版出现并一直被保留至今，是名副其实的“元老”。</p>

<p>它的含义是请求<strong>从服务器获取资源</strong>，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。</p>

<p><strong>HEAD</strong>方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。</p>

<p>HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。</p>

<p>GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，向 URI 指定的资源提交数据，数据就放在报文的 body 里。</p>

<p>POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，只要向服务器发送数据，用的大多数都是 POST。</p>

<p><strong>DELETE</strong>方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。</p>

<p><strong>CONNECT</strong>是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。</p>

<p><strong>OPTIONS</strong>方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</p>

<p><strong>TRACE</strong>方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</p>

<p>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</p>

<h2>安全与幂等</h2>

<p>关于请求方法还有两个面试时有可能会问到、比较重要的概念：<strong>安全</strong>与<strong>幂等</strong>。</p>

<p>在 HTTP 协议里，所谓的“<strong>安全</strong>”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</p>

<p>所谓的“<strong>幂等</strong>”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</p>

<p>很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。</p>

<p>按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。</p>

<h2>URI 的基本组成</h2>

<p>下面的这张图显示了 URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。</p>

<p><img src="https://static001.geekbang.org/resource/image/46/2a/46581d7e1058558d8e12c1bf37d30d2a.png" alt=""></p>

<h2>URI 的基本组成</h2>

<p>URI 第一个组成部分叫<strong>scheme</strong>，翻译成中文叫“<strong>方案名</strong>”或者“<strong>协议名</strong>”，表示<strong>资源应该使用哪种协议</strong>来访问。</p>

<p>最常见的当然就是“http”了，表示使用 HTTP 协议。另外还有“https”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。</p>

<p>浏览器或者你的应用程序看到 URI 里的 scheme，就知道下一步该怎么走了，会调用相应的 HTTP 或者 HTTPS 下层 API。显然，如果一个 URI 没有提供 scheme，即使后面的地址再完善，也是无法处理的。</p>

<p>在 scheme 之后，必须是<strong>三个特定的字符</strong>“<strong>://</strong>”，它把 scheme 和后面的部分分离开。</p>

<p>在“://”之后，是被称为“<strong>authority</strong>”的部分，表示<strong>资源所在的主机名</strong>，通常的形式是“host:port”，即主机名加端口号。</p>

<p>有了协议名和主机地址、端口号，再加上后面<strong>标记资源所在位置</strong>的<strong>path</strong>，浏览器就可以连接服务器访问资源了。</p>

<p>这里我也要再次提醒你注意，URI 的 path 部分必须以“/”开始，也就是必须包含“/”，不要把“/”误认为属于前面 authority。</p>

<p>说了这么多“理论”，来看几个实例。</p>

<code class="ps"><table class="hljs-ln"><tbody><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">http://nginx.org</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">http://www.chrono.com:8080/11-1</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">https://tools.ietf.org/html/rfc7230</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">file:///D:/http_study/www/</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line"><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></td></tr></tbody></table><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></code>

<p>第一个 URI 算是最简单的了，协议名是“http”，主机名是“nginx.org”，端口号省略，所以是默认的 80，而路径部分也被省略了，默认就是一个“/”，表示根目录。</p>

<p>第二个 URI 是在实验环境里这次课程的专用 URI，主机名是“www.chrono.com”，端口号是 8080，后面的路径是“/11-1”。</p>

<p>第三个是 HTTP 协议标准文档 RFC7230 的 URI，主机名是“tools.ietf.org”，路径是“/html/rfc7230”。</p>

<p>最后一个 URI 要注意了，它的协议名不是“http”，而是“file”，表示这是本地文件，而后面居然有三个斜杠，这是怎么回事？</p>

<p>如果你刚才仔细听了 scheme 的介绍就能明白，这三个斜杠里的前两个属于 URI 特殊分隔符“://”，然后后面的“/D:/http_study/www/”是路径，而中间的主机名被“省略”了。这实际上是 file 类型 URI 的“特例”，它允许省略主机名，默认是本机 localhost。</p>

<p>但对于 HTTP 或 HTTPS 这样的网络通信协议，主机名是绝对不能省略的。原因之前也说了，会导致浏览器无法找到服务器。</p>













